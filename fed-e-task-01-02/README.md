### 简答题答案以及说明

#### 一，请说出下列最终执行的结果，并解释为什么

- 结果: 10
- 原因
  - i 使用 var 声明，for 循环执行完成后，i = 10
  - 所以所有的 a 序列 0-10 的函数内部，i 的值都是 10

#### 二，请说出下列最终执行的结果，并解释为什么

- 结果：报错 -> 使用 tmp 需要先定义
- 原因
  - {} 为 块级作用域
  - 变量的查找规则 是 先近 后远
  - 在块级作用域内 tmp 使用 let 声明
  - 而 let 声明，需要先声明，后使用

#### 三，第三题路径

- fed-e-task-01-02/code/1.code.js

#### 四，var,let,const 方式声明之间的具体差别

- var

  - 作用域
    - 全局作用域
    - 局部作用域
      - 在函数内使用，仅在函数内部生效
  - 变量的值查找，满足就近原则
  - 变量提升
    - var 其实是做了两个部分，一个部分定义，一个部分为赋值
    - 在 声明变量之前使用，默认值为 undefined
  - 值可以任意赋值

- let

  - 作用域
    - 全局作用域
    - 块级作用域
  - 变量的值查找，满足就近原则
  - 仅可在声明后使用
  - 值可以任意赋值

- const
  - 作用域
    - 全局作用域
    - 块级作用域
  - 变量的值查找，满足就近原则
  - 仅可在声明后使用
  - 仅可在声明时候，赋值，之后值不能更改

#### 五，请说出下列最终执行的结果，并解释为什么

- 结果: 20
- 原因
  - obj 的 fn 使用的 函数声明，当前 函数内部的 this 指向 obj
  - setTimeout 内的函数 使用 箭头函数
  - 箭头函数的作用域为执行时的 上下文，这时 this 指向 obj,this.a 为 obj.a
  - 所以值 为 20

#### 六, 简述 Symbol 用途

- 当需要一个唯一值时，可以使用 Symbol

#### 七，浅拷贝，深拷贝

- js 类型中分为，基础类型，与地址类型（引用类型）（array,object...等）
- 因为 地址类的类型数据，会分为两部分存储，一部分为变量+地址引用地址，一部分为真正的值
- 浅拷贝
  - 对于地址类的值，仅将地址赋值给新的变量
  - 当操作变量时，等同于所有的变量都在变更
- 深拷贝
  - 重新 申请类新的地址，并将值存在新的地址内
  - 操作变量，不会影响原来的变量

#### 八，请简述 ts 与 js 的关系

- 首先，js 是弱类型语言，在代码运行的过程中，变量可以任意被赋值，任意类型的变量，在代码执行中，类型的定义靠 约定，代码正常执行，不能完全正常把控
- 各个运行 js 的终端，因为版本的不同，对于 js 有不同的 ecma 版本类型限制，不用任何 转换插件的情况下，很难做到 js ecma 的版本统一
- ts 为 js 的语法类型扩展，所以称为 js 的超级
- 在 js 开发过程中，在开发环境，开发着可以靠类型注解，标注当前运行代码的类型，返回值，等，方便协作开发，与异常把控
- 作为新的 ecma 版本，或者其他的 依赖库，ts 也可以引用支持，最终通过 ts config 配置，将 开发的代码，编译为 适合各个终端，执行的 ecma 低等级版本

#### 九，ts 优缺点

- 优点

  - 控制 代码的开发过程中的语法类型，让代码变的可控
  - 团队成员之间协作更加方便

- 缺点
  - 学习成本
  - 对于老的依赖包，不那么友好的兼容
  - 需要将 ts 文件编译为 js 文件后，才能用于终端执行

#### 十，引用计数的工作原理，和优缺点

- 原理
  - 当 对象被引用的时候，引用数量记录 + 1
  - 当 对象的 引用计数 为 0 时，被回收
- 优点
  - 即时清理
  - 因为为即时的，很大程度上减少程序的暂停
- 缺点
  - 循环引用对象无法回收，循环引用的对象，引用数量记录，数量不为 0
  - 对象比较大的时候，需要层层查找引用关系，并记录数量，整个过程比较长

#### 十一，标记整理算法的工作流程

- 查找对象，对对象作标记
- 将未标记完成的对象，不工作的对象做清除
- 将当前标记，仍在使用的对象，整理在一起
- 将当前空闲的空间，整理排列在一起，用于之后开销
