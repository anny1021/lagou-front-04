### 性能优化 - js 语言的优化

#### 优化

- 无处不在的前端性能优化

#### 内存

- 内存管理
  - 申请 -> 使用 -> 释放
- 内存管理是自动的，对象不再引用时就变为类垃圾

#### 垃圾回收 GC 算法

- js 中的垃圾
  - 当 代码中的对象，不在被引用的时候，不能从根上访问时
- 垃圾回收
  - 将不引用的对象，回收释放
- 可达对象
  - 是否从根上触发能够被找到
  - 根 -> 全局变量对象
- GC
  - GC -> 垃圾回收机制的简写
  - GC 回收垃圾的一种机制
  - GC 算法 -> 执行回收的时候，所遵循的原则
    - 常见的 GC 算法
      - 引用计数
        - 当 对象被引用的时候，引用数量记录 + 1
        - 当 对象的 引用计数 为 0 时，被回收
        - 优点
          - 即时清理
          - 减少程序的暂停
        - 缺点
          - 循环引用对象无法回收
          - 对象比较大的时候，事件开销比较大
      - 标记清除
        - 找到未使用的，然后清除
        - 优点
          - 可回收循环引用对象
        - 缺点
          - 回收后的空间有断裂，碎片化的空间，浪费空间
          - 反应比较慢，因为需要先标记
      - 标记清理
        - 先做 标记清除
        - 在将 已使用 与 未使用的 空间进行整理
        - 缺点
          - 需要先标记，回收，整理空间
          - 不会立即回收
          - 整理空间，回收的效率比较慢
      - 分代回收
        - 新生代
        - 老生代

#### V8 引擎的垃圾回收

- v8
  - 主流的 js 执行引擎
  - 即时编译
  - 内存设置限制
- v8 的垃圾 回收
  - 分代回收
  - 内存也分代
    - 新生代
      - 32M ｜ 16M
  - 判断对象类型，针对对象类型采用不同的算法
- v8 常用的 GC 算法
  - 分代回收
    - 新生代 -> 存活时间较短的对象 -> 空间换时间
      - from 使用空间，活动对象存储于 from 空间
      - to 空闲空间 -> 标记整理后 将活动对象拷贝到这里
      - from 与 to 空间交换，完成内存释放
    - 老生代 -> 存活时间比较长的对象 -> 不适合复制的算法
      - 大小限制
        - 1.4G | 700M
  - 空间复制
  - 标记清除 -标记整理
  - 标记增量
    - 将整个标记的过程，拆分成小的标记段执行，最后一起清除
    - 小的标记段，在程序执行的间隔中完成

#### performance 工具

- 浏览器自带的 内存表格列 查看内存运行情况
- 浏览器
  - -> 开发者调试 -> 性能
    - timeline
  - 快找查找 分离 dom
    - Detached dom

#### 总结

- 内存问题的页面表现

  - 延迟加载，暂停
  - 持续性卡屏
  - 打开页面时间越久，性能越来越差

- 判断内存是否有问题的标准
  - 内存泄漏
  - 内存膨胀
  - 频繁的垃圾回收
    - 频繁 高低 js 回收线
